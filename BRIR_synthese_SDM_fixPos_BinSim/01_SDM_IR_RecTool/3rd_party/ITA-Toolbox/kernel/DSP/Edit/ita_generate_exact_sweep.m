function varargout = ita_generate_exact_sweep(varargin)
%ITA_GENERATE_SWEEP - Generate nice sweeps for measurements
%  This function generates nice sweeps (lin or exp) used for measurements.
%  The method used is described in the PhD thesis of Antonin Novak
%
%  only exponential sweeps

% <ITA-Toolbox>
% This file is part of the ITA-Toolbox. Some rights reserved.
% You can find the license for this m-file in the license.txt file in the ITA-Toolbox folder.
% </ITA-Toolbox>


% Author: Pascal Dietrich -- Email: pdi@akustik.rwth-aachen.de
% Created:  21-Feb-2012

%% Initialization and Input Parsing
sArgs        = struct('sweeprate', 5,'samplingRate',ita_preferences('samplingRate'),...
    'stopMargin',0.1,'freqRange',[5 20000],'bandwidth',0/12,'phi0',0);
[sArgs]      = ita_parse_arguments(sArgs,varargin);
sweeprate    = sArgs.sweeprate;

%pdi: new sweep generation, both linear and exponential sweeps
%are generated by going from f_low/sqrt(2) till f_high*sqrt(2).
%Then, a zerophase bandpass is applied to allow a smooth
%frequency response.

f1_raw       = sArgs.freqRange(1);
f2_raw       = sArgs.freqRange(2);
bandwidth    = sArgs.bandwidth;
samplingRate = sArgs.samplingRate;

f1  = f1_raw/2^(bandwidth); %little smaller than requested!
f2  = min(f2_raw*2^(bandwidth),samplingRate/2);

%% bandwidth
if f1 <= 1e-6
    ita_verbose_info('The lowest frequency has to be greater than 1e-6 ',1);
    f1 = 1e-6 * 2^(bandwidth); %bma
end

%% synchronized sweeps after Antonin Novak, Analysis, Synthesis, and Classification of Nonlinear Systems Using Synchronized Swept-Sine Method for Audio Effects, EURASIP Journal on Advances in Signal Processing, 2010
L                       = 1/sweeprate/log(2); %convert to L-sweep rate
T                       = L*log(f2/f1);

%% generate sweep and settings for itaAudio
audioObj                = itaAudio;
audioObj.samplingRate   = samplingRate;
nSamples                = round( T*sArgs.samplingRate ) ; %even samples
audioObj.nSamples       = nSamples;
t                       = audioObj.timeVector;

%% generate sweep and store in itaAudio
sweep = sin(2*pi*f1*L .*(exp(t/L)-1) + sArgs.phi0); % Novak eq.4.1
audioObj.timeData = sweep;

%% post processing
% CAREFUL smoothing in the end
high_fade_sample_vec =  [-round(100*samplingRate/f2 + 2), 0]+audioObj.nSamples;
audioObj = ita_time_window(audioObj,high_fade_sample_vec,'samples');

%extending to double size
audioObj = ita_extend_dat(audioObj,nSamples*2); %get the full length signal as requested

if f2 < samplingRate/2
    f2_final = max(min(f2*2^(bandwidth),samplingRate/2*0.95),f2);
    audioObj = ita_mpb_filter(audioObj,[0 f2_final],'order',14);
end

audioObj            = ita_normalize_dat(audioObj);
audioObj.nSamples   = ceil( (nSamples + sArgs.stopMargin * sArgs.samplingRate)/2 )*2;

%% Add history line
audioObj.comment      = [  'exp Sweep ' num2str(f1) ' to ' num2str(f2) 'Hz'];
audioObj.channelNames{1} = audioObj.comment;
audioObj = ita_metainfo_add_historyline(audioObj,mfilename,varargin);

%% Set Output
varargout(1) = {audioObj};
if nargout >= 2
    %     audioObj2 = 0*audioObj; %get instantaneous frequency -- without lowpass filter influence !!!
    %     audioObj2.time(1:numel(instPhi)) = (instPhi/L + 1)* f1use ;
    %     audioObj2 = itaValue(1,'Hz') * audioObj2;
    %     varargout(2) = {audioObj2};
    
    varargout{2} = sweeprate;
    if nargout == 3
        varargout{3} = Lf1;
    end
end

%end function
end