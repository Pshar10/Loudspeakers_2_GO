function varargout = ita_generate_sweep_novak(varargin)
%ITA_GENERATE_SWEEP - Generate nice sweeps for measurements
%  This function generates nice sweeps (lin or exp) used for measurements.
%  The method used is described in the PhD thesis of Antonin Novak
%
%  only exponential sweeps

% <ITA-Toolbox>
% This file is part of the ITA-Toolbox. Some rights reserved.
% You can find the license for this m-file in the license.txt file in the ITA-Toolbox folder.
% </ITA-Toolbox>


% Author: Pascal Dietrich -- Email: pdi@akustik.rwth-aachen.de
% Created:  21-Feb-2012

%% Initialization and Input Parsing
sArgs        = struct('fftDegree', ita_preferences('fftDegree'),'novakround',false,'samplingRate',ita_preferences('samplingRate'),...
    'stopMargin',0.1,'freqRange',[5 20000],'bandwidth',2/12,'phi0',0);
[sArgs] = ita_parse_arguments(sArgs,varargin);

%pdi: new sweep generation, both linear and exponential sweeps
%are generated by going from f_low/sqrt(2) till f_high*sqrt(2).
%Then, a zerophase bandpass is applied to allow a smooth
%frequency response.

f1_raw       = sArgs.freqRange(1);
f2_raw       = sArgs.freqRange(2);
bandwidth    = sArgs.bandwidth;
samplingRate = sArgs.samplingRate;

f1  = f1_raw/2^(bandwidth); %little smaller than requested!
f2  = min(f2_raw*2^(bandwidth),samplingRate/2);

%% fft degree or number of samples?
nSamples   = ita_nSamples(sArgs.fftDegree);
tmpSamples = nSamples;
nSamples   = nSamples - round(sArgs.stopMargin.*samplingRate./2)*2;
if nSamples <= 0;
    error(['ITA_GENERATE:Stop margin is too long. Maximum is ' num2str(tmpSamples ./ samplingRate) '.'])
end
if f1 <= 1e-6
    ita_verbose_info('The lowest frequency has to be greater than 1e-6 ',1);
    f1 = 1e-6 * 2^(bandwidth); %bma
end

%% generate sweep and settings for itaAudio
audioObj              = itaAudio;
audioObj.samplingRate = samplingRate;
audioObj.fftDegree    = nSamples;

%% synchronized sweeps after Antonin Novak, Analysis, Synthesis, and Classification of Nonlinear Systems Using Synchronized Swept-Sine Method for Audio Effects, EURASIP Journal on Advances in Signal Processing, 2010
T = audioObj.timeVector(end);

if sArgs.novakround
    L =  round(f1*T/log(f2/f1))/f1;
    T =  L * log(f2/f1); % length of signal
    audioObj.trackLength = T;
    Lf1 = L*f1;
else
    L = T/log(f2/f1);
    Lf1 = f1*T/log(f2/f1);
    %     phase_deg = 360 * Lf1 * (1:5);
    %     disp(mod(phase_deg+180,360)-180)
    %     disp('Phase offset in harmonics due to sweep rate (other than novak sweep)')
    % phase offset of fundamental has to be subtracted since this offset
    %     % is already corrected by the deconvolution with the sweep
    %     phase_offset_sweeprate = -mod((phase_deg - phase_deg(1))+180,360)-180;
    % % %     factor_sweeprate = exp(1i*phase_offset_sweeprate);
    %     disp(phase_offset_sweeprate); % - due to (exp(x) - 1) -> -1 results in -2*pi*
end
sweeprate = 1/L/log(2);
L
L = 1/sweeprate/log(2)
t = audioObj.timeVector;
nSamples = audioObj.nSamples;

% nOrders = 5; %number of harmonic orders for phase evaluation
% disp('phase offset due to phi0 degrees')
% phase0 = (mod(sArgs.phi0 * ((1:nOrders) - 1)+pi,2*pi)-pi) /pi*180;
% disp(phase0);
% 
% %pdi: evaluate phase offsets -> with novak rounding this should be zero!
% disp('phase offset due to sweep rate in degrees')
% phase = (mod(2*pi*f1*L.*(1:nOrders)+pi,2*pi)-pi)/(pi)*180;
% disp(phase);

%% generate sweep and store in itaAudio
sweep = sin(2*pi*f1*L .*(exp(t/L)-1) + sArgs.phi0); % Novak eq.4.1
audioObj.timeData = sweep;

%% post processing
% CAREFUL smoothing in the end
high_fade_sample_vec =  [-round(100*samplingRate/f2 + 2), 0]+audioObj.nSamples;
audioObj = ita_time_window(audioObj,high_fade_sample_vec,'samples');

%extending to double size
audioObj = ita_extend_dat(audioObj,nSamples*2); %get the full length signal as requested

if f2 < samplingRate/2
    f2_final = max(min(f2*2^(bandwidth),samplingRate/2*0.95),f2);
    audioObj = ita_mpb_filter(audioObj,[0 f2_final],'order',14);
end

audioObj = ita_extract_dat(audioObj,sArgs.fftDegree);
audioObj = ita_normalize_dat(audioObj);


%% Add history line
audioObj.comment      = [  'exp Sweep ' num2str(f1) ' to ' num2str(f2) 'Hz'];
audioObj.channelNames{1} = audioObj.comment;
audioObj = ita_metainfo_add_historyline(audioObj,mfilename,varargin);

%% Set Output
varargout(1) = {audioObj};
if nargout >= 2
    %     audioObj2 = 0*audioObj; %get instantaneous frequency -- without lowpass filter influence !!!
    %     audioObj2.time(1:numel(instPhi)) = (instPhi/L + 1)* f1use ;
    %     audioObj2 = itaValue(1,'Hz') * audioObj2;
    %     varargout(2) = {audioObj2};
    
    varargout{2} = sweeprate;
    if nargout == 3
        varargout{3} = Lf1;
    end
end

%end function
end