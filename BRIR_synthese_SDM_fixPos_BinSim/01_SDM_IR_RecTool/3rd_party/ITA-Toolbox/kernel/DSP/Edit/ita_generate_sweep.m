function varargout = ita_generate_sweep(varargin)
%ITA_GENERATE_SWEEP - Generate nice sweeps for measurements
%  This function generates nice sweeps (lin or exp) used for measurements.
%  Improvements to ita_generate
%
%  Syntax:
%   audioObjOut = ita_generate_sweep(audioObjIn, options)
%
%   Options (default):
%           'fftDegree' (16):               fftDegree / or number of samples
%           'mode' ('exp'):                 'lin' or 'exp'
%           'samplingRate' (44100):         samplingRate
%           'stopMargin' (0.1):             stopMargin
%           'freqRange' ([5 20000]):        start and stop frequency
%           'bandwidth' (2/12):             Extend the frequency range by this bandwidth
%
%  Example:
%   audioObjOut = ita_generate_sweep(audioObjIn)
%
%  See also:
%   ita_toolbox_gui, ita_read, ita_write, ita_generate
%
%   Reference page in Help browser
%        <a href="matlab:doc ita_generate_sweep">doc ita_generate_sweep</a>

% <ITA-Toolbox>
% This file is part of the ITA-Toolbox. Some rights reserved. 
% You can find the license for this m-file in the license.txt file in the ITA-Toolbox folder. 
% </ITA-Toolbox>


% Author: Pascal Dietrich -- Email: pdi@akustik.rwth-aachen.de
% Created:  20-Apr-2011

%% Initialization and Input Parsing
% all fixed inputs get fieldnames with posX_* and dataTyp
% optonal inputs get a default value ('comment','test', 'opt1', true)
% please see the documentation for more details
sArgs        = struct('mode','exp', 'fftDegree', ita_preferences('fftDegree'),'samplingRate',ita_preferences('samplingRate'),...
    'stopMargin',0.1,'freqRange',[5 20000],'bandwidth',2/12,'novak',false,'gui',false);
[sArgs] = ita_parse_arguments(sArgs,varargin);

if sArgs.gui %automatic gui
    sArgs.varname = 'outputVariableName';
    [sArgs] = ita_parse_arguments_gui(sArgs);
    if isempty(sArgs) % user has cancelled
        ita_verbose_info('Operation cancelled by user',1);
        return;
    end
end

%pdi: new sweep generation, both linear and exponential sweeps
%are generated by going from f_low/sqrt(2) till f_high*sqrt(2).
%Then, a zerophase bandpass is applied to allow a smooth
%frequency response.
switch lower(sArgs.mode)
    case {'lin','linear'}
        methodStr = 'linear';
        methodStrShow = 'linear';
    case {'exp','exponential','log','logarithmic'}
        methodStr = 'logarithmic';
        methodStrShow = 'exponential';
    otherwise
        error('unknown sweep mode!')
end
f0 = sArgs.freqRange(1);
f1 = sArgs.freqRange(2);
bandwidth = sArgs.bandwidth;
samplingRate = sArgs.samplingRate;

%% fft degree or number of samples?
nSamples   = ita_nSamples(sArgs.fftDegree);
tmpSamples = nSamples;
nSamples   = nSamples - round(sArgs.stopMargin.*samplingRate./2)*2;
if nSamples <= 0;
    error(['ITA_GENERATE:Stop margin is too long. Maximum is ' num2str(tmpSamples ./ samplingRate) '.'])
end
t   = (1:nSamples-1)./samplingRate;
t1  = (nSamples-1)./samplingRate;
phi = -90;% -90; does not work: pdi: now it works as hell! april 2011
if f0 <= 1e-6
    ita_verbose_info('The lowest frequency has to be greater than 1e-6 ',1);
    f0 = 1e-6 * 2^(bandwidth); %bma
end

%% generate sweep and settings for itaAudio
audioObj = itaAudio;
audioObj.samplingRate = samplingRate;
audioObj.fftDegree    = nSamples;

if sArgs.novak %synchronized sweeps after Antonin Novak, Analysis, Synthesis, and Classification of Nonlinear Systems Using Synchronized Swept-Sine Method for Audio Effects, EURASIP Journal on Advances in Signal Processing, 2010
    f0use  = f0/2^(bandwidth); %little smaller than requested!
    f1use  = min(f1*2^(bandwidth),samplingRate/2);
    L      = 1/f0use * round(f0use * (double(audioObj.trackLength) * f0use / log(f1use/f0use))); %pdi: round as in novak paper does not work in general!
    instFreq = L.*(exp(f0use.*audioObj.timeVector/L) -1);
    audioObj.timeData = sin(2*pi*instFreq);
    instPhi = t1/log(f1/f0)*(f0*(f1/f0).^(t/t1)-f0);
else
    audioObj.timeData = chirp(audioObj.timeVector,f0/2^(bandwidth),t1,min(f1*2^(bandwidth),samplingRate/2),methodStr,phi);
end
audioObj.comment         = sprintf('%s Sweep %1.2f to %1.2f Hz', methodStrShow, f0 , f1);
audioObj.channelNames{1} = audioObj.comment;

% CAREFUL smoothing in the end
high_fade_sample_vec =  [-round(100*samplingRate/f1 + 2), 0]+audioObj.nSamples;
audioObj = ita_time_window(audioObj,high_fade_sample_vec,'samples');

%extending to double size
audioObj = ita_extend_dat(audioObj,nSamples*2); %get the full length signal as requested

if f1 < samplingRate/2
    f1_final = max(min(f1*2^(bandwidth),samplingRate/2*0.95),f1);
    audioObj = ita_mpb_filter(audioObj,[0 f1_final],'order',14);
end

audioObj = ita_extract_dat(audioObj,sArgs.fftDegree);
audioObj = ita_normalize_dat(audioObj);

%% Add history line
audioObj = ita_metainfo_add_historyline(audioObj,mfilename,varargin);

%% Set Output
if sArgs.gui
   ita_setinbase(sArgs.varname,audioObj); 
end
varargout(1) = {audioObj};
if nargout == 2 && sArgs.novak
    audioObj2 = 0*audioObj; %get instantaneous frequency -- without lowpass filter influence !!!
    audioObj2.time(1:numel(instPhi)) = (instPhi/L + 1)* f0use ;
    audioObj2 = itaValue(1,'Hz') * audioObj2;
    varargout(2) = {audioObj2};
end

%end function
end